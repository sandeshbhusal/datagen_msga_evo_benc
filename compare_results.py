'''
Compare the invariants generated by datagen vs evosuite
'''

# Make sure the 'dig' submodule is checked out in datagen.
import os.path as pth
import glob
import shutil
import re
import subprocess
from typing import List
from datagen import smtgen

filedir = pth.dirname(__file__)
assert (pth.exists(pth.join(filedir, "datagen", "dig"))), "DIG is not available. Make sure to run git submodule update --init --recursive"

# Make sure the "data" folder is available. We need two folders in "data", namely,
# "evosuite" for evosuite and "datagen" for datagen's output. Both of these folders contain
# the output from running the datagen tool, with and without augmentation on evosuite.

benchmarks_evosuite = set([f.removeprefix("data/evosuite") for f in glob.glob("data/evosuite/*")])
benchmarks_datagen  = set([f.removeprefix("data/datagen") for f in glob.glob("data/datagen/*")])

candidates = set()

if benchmarks_evosuite != benchmarks_datagen:
    # We have a mismatch! Run only common benchmarks for now, but warn.
    print(f"MISMATCH! {benchmarks_datagen.difference(benchmarks_evosuite)} are only in datagen and {benchmarks_evosuite.difference(benchmarks_datagen)} are only in evosuite!")
    # We always consider datagen as first-class citizens.
    candidates = benchmarks_datagen.intersection(benchmarks_evosuite)
else:
    candidates = benchmarks_datagen

print("Running benchmarks: \n------------------------------\n" + '\n'.join(candidates))

# Run DIG first on all *.csv files.
dig_invariants = {}

def get_invariants_from_dig(filepath: str):
    # Generate invariant!
    cmd = [
        "python3",
        "-O",
        "datagen/dig/src/dig.py",
        f"{dg_file}"
    ]

    try:
        output = subprocess.run(cmd, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    except Exception as e:
        print(e)
        exit(-1)

    if output.returncode != 0:
        print("DIG ended with a non-zero status code.")
        print("STDERR: \n" + output.stderr.decode(encoding='utf-8') if output.stderr else "")
        print("STDOUT: \n" + output.stdout.decode(encoding="utf-8") if output.stdout else "")

    out = output.stdout.decode(encoding = "utf-8") if output.stdout else ""
    err = output.stderr.decode(encoding = "utf-8") if output.stderr else ""

    # TODO: make sure there's no err.

    # Now that we have the stdout, grab all the "invariant" lines.

    invline_re = re.compile(r"\d+\. (.+)")
    invariants = []
    for line in out.splitlines():
        if invline_re.match(line):
            # Get group
            matched = invline_re.match(line)
            invariant = matched.group(1)
            invariants.append(invariant)

    return invariants

def get_daikon_invariants(dtrace_file: str) -> List[str]:
    # Make sure that all jar files are added to classpath.
    libpath = pth.join("datagen", "libs")
    assert(pth.exists(libpath)), "Jar files are missing. Put daikon+deps in datagen/libs/"
    all_jar_deps = glob.glob(pth.join(libpath, "*.jar"))
    deps_to_cp = ":".join(all_jar_deps)
    cmd = [
        "java",
        "-cp",
        deps_to_cp,
        "daikon.Daikon",
        dtrace_file
    ]
    try:
        output = subprocess.run(cmd, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        if output.returncode != 0:
            print("Daikon exited with code: ", output.returncode)
            if output.stderr:
                print("STDERR: \n", output.stderr.decode("utf-8"))
        
        out = output.stdout.decode("utf-8") if output.stdout else ""
        err = output.stderr.decode("utf-8") if output.stderr else ""

        # Daikon is a bit tricky. We need to read everything after the line that
        # contains ======= (at least 5 equals), upto the end.
        invariants = []
        start = False
        for line in out.splitlines():
            if start:
                invariants.append(line.strip())
            if "=====" in line:
                start = True
        return invariants

    except Exception as e:
        print(e)
        # TODO: Replace with crash.
        return []


ITERATION = 20

for candidate in candidates:
    # Enumerate all data files for DIG.
    datagen_files_csv  = glob.glob(f"data/datagen/{candidate}/checkpoint/{ITERATION}/code/*.csv")

    # Compare against evosuite. The file path should be same, except, it contains "evosuite"
    for dg_file in datagen_files_csv:
       
        evo_file = dg_file.replace("datagen", "evosuite")
        assert(pth.exists(evo_file)), "Evosuite file is missing. Error in intersection logic."

        datagen_invariants = get_invariants_from_dig(dg_file)
        evo_invariants     = get_invariants_from_dig(evo_file)

        with open("/tmp/dg.txt", "w") as dgfile:
            dgfile.write("\n".join(datagen_invariants))

        with open("/tmp/evo.txt", "w") as evfile:
            evfile.write("\n".join(evo_invariants))

        # smtfile = smtgen.generate_smtlibqueryfile_from_files("/tmp/dg.txt", "/tmp/evo.txt")

    datagen_files_dtrace = glob.glob(f"data/datagen/{candidate}/checkpoint/{ITERATION}/code/*.dtrace")

    for dg_file in datagen_files_dtrace:
        evo_file = dg_file.replace("datagen", "evosuite")
        assert(pth.exists(evo_file)), "Evosuite file is missing for Daikon."

        datagen_invariants = get_daikon_invariants(dg_file)
        evo_invariants     = get_daikon_invariants(evo_file)

        # TODO: Make sure to clean up any ".inv.gz" files afterwards.
        artifacts = glob.glob("*.inv.gz") 

        print('\n'.join(datagen_invariants) + "\n--------------------\n"+ '\n'.join(evo_invariants))
        print("==============================")